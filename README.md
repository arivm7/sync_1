# Скрипт для персональной синхронизации.
Испольтзует rsync через ssh.

Не для совместной работы. 
> Проблема совместной работы заключается в том, 
> что синхронизация происходит по дате изменения файлов. 
> Если над одним файлом работали в двух местах то сохранится только тот, который изменяли позже.

## Суть работы

Если всё упростить, то программа rsync может копировать файлы двумя способами:
1. Копировать файлы с первой папки во вторую и при совпадении имён файлов старый фал переписывается новым. При таком способе удаление файлов не происходит, а только добавляются новые файлы.
2. Копировать файлы с первой папки во вторую с удалением расхождений. Все файлы исходной папки считаются правильными и все расхождения в папке назначения удаляются, не взирая на метки времени.  

Если на двух папках использовать программу rsync в обе стороны для копирования без удаления (вариант 1.) в обе стороны, то файлы в этих папках будут всегда одинаковые.\
**Так происходит синхронизация.**

Для удаления файлов используется режим копирования с удалением расхождений (вариант 2.).\
**Так происходит управление файлами, удаление 'лишних'.**

Собственно на этих двух режимах копирования rsync и построен синхронизатор.

**Программа представляет собой один shell скрипт, использующий rsync работающий поверх ssh.**

Где-то на удаленном всегда включённом компьютере, NASе с поддержкой ssh, или на корпоративном сервере, есть место, к которому есть доступ по ssh-протоколу с установленными ключами, чтобы доступ был без пароля. 

> ![Важно]\
> Доступ к серверу должен быть именно по ключам,\
> чтобы подключение происходило **без запроса пароля**,\
> поскольку за одну синхронизацию происходит несколько запросов

На одном Вашем компьютере есть папка на диске, которая просто синхронизируется с помощью RSYNC с папкой на сервере.
На другом Вашем компьютере есть такая-же папка для которой запускается rsync для её синхронизации с папкой на сервере.
Команда синхронизации запускается в ручную или устанавливается в crontab и происходит автоматически по указанному в crontab расписанию.
При этом получается что все папки всегда полностью одинаковы.

По сути работы -- это всё.


## Скриншоты

![Screenshot_01](img/Screenshot_01.png)


## Далее детали.

При такой конфигурации системы не возможно удалить файл, поскольку при следующей итерации синхронизации он восстановится с сервера.
Для этого на компе где я хочу удалить файл (перенести в другую папку), я должен запустить rsync с параметрами, чтобы все разночтения были удалены с сервера.

На самом сервера ставится метка для клиентских компов о том, что им нужно считать синхронизацию так, чтобы считать всё с сервера и удалить различия у себя.

Эта процедура происходит один раз, за тем происходит обычная синхронизация папок.

Что-бы устанавливать статус синхронизации для клиентов, на сервер пришлось ввести список "клиентов" с установлением для них статуса.
т.е. если к папке синхронизации подключено несколько компов, то при отправке на сервер команды на удаление файлов для всех клиентов 
устанавливается статус взять с сервера и удалить у себя, после чего для этого клиента устанавливается статус регулярных синхронизаций.
При этом, если какой-то клиент подключится через неделю, то он всё равно получит команду обновить свои данные так, чтобы взять всё с сервера и различия у себя удалить.


## Назначение скриптов

### sync_1.sh 

-- Собственно это и есть скрипт синхронизации. 
Для работы достаточно его одного. 
Все действия по синхронизации делает именно этот скрипт, 
все другие -- просто вспомогательные.

### sync_1_aliases.sh

-- это скрипт содержит записи alias для удобства использования основного скрипта\
и строку для автодополнений. \
Всё это для включения в конфиг-файл консоли (.bashrc).

Он включается скриптом инсталлятором (sync_install.sh) \
или в ручную в '.bashrc' как include \
обычно так: '. /path/sync_1_aliases.sh' \
Алиасы заменяю длинное название скрипта **sync_1.sh** на короткое **s1** \
или можете их переписать на свой вкус. 

### sync_all.sh

-- Скрипт для синхронизации списка папок.
У него есть конфиг-файл **sync_all.list** в котором просто перечислены 
папки для синхронизации и текстовое сообщение-баннер для оформления лога синхронизации (не обязательно) \
Пример файла **sync_all.list** есть в дистрибутиве.

Этот скрипт можно запускать из cron, настроив параметры запуска в 'crontab -e'


### sync_backuper.sh

Скрипт для простого резервного копирования с ротацией архивов.

Конфигурация:
> Конфиг-файл: '~/.config/sync/sync_backuper.conf' \
> Список папок для архивации берётся из файла: ~/.config/sync/sync_backuper.list \
> Архивы по умолчанию сохраняются в папке: ~/Backups/syncBackups (можно изменить в конфиге)

Параметры запуска:
> --dry-run, -n  Выполнить только расчёт (размеры, свободное место), без создания архивов\
> --edit-conf    Редактирование конфига\
> --edit-list    Редактирование списка для бакапа


### sync_install.sh

-- Установочный скрипт.

1. Устанавливает файлы зависимостей, обязательных и не очень.
2. Копирует скрипты **sync_1.sh**, **sync_1_aliases.sh**, **sync_all.sh** и **sync_backuper.sh** в папку **$HOME/bin**
3. В папке ```~/.config/sync/``` проверяет наличие конфигурационных файлов и списков. Если их нет, то копирует.   
4. Копирует иконки в папку иконок ```~/bin/icons```
5. Копирует .desktop-файлы в папку для десктоп-файлов ```~/.local/share/applications```
6. Внутри .desktop-файлов исправляет пути к иконкам, исполняемым скриптам и текущий путь
7. Проверяет наличие include вставки ```sync_1_aliases.sh``` в .bashrc файле. Если её там нет, то вписывает.



## Автоматическая синхронизация cron

Чтобы происходила автоматическая синхронизация, Вам нужно вписать команду синхронизации в crontab.

Выполните:

    crontab -e

и добавьте нужные вам скрипты для автозапуска.

**[!ВАЖНО]**\
При добавлении какого-либо скрипта в crontab нужно добавить 
в cron-скрипт переменные окружения, которые нужны этому скрипту, 
и которые отсутсвуют при выполнении скрипта не в пользовательском 
окружении: cron, systemd, или другой фоновый запуск.
примерно так:

    PATH=/usr/local/bin:/usr/bin:/bin:/home/user/bin:/home/user/.local/bin
    HOME=/home/user
    USER=user
    SHELL=/bin/bash
    1  *  *  *  *    /home/user/bin/sync_all.sh
    1  1  *  *  6    /home/user/bin/sync_backuper.sh
    #
    # для контроля исполнения скрипта можно \
    # добавить логирование работы самого скрипта:
    1  *  *  *  *    /home/user/bin/sync_all.sh >> /home/user/sync_all_cron.log 2>&1
    1  1  *  *  6    /home/user/bin/sync_backuper.sh >> /home/user/sync_backuper_cron.log 2>&1


## Команды тестирования


### SHOW_DEST

-- Выводит строку из файла '```.sync/dest```'.
Это адрес размещения папки на облачном сервере. Обычно вида '```user@host:/путь/папка```'.


### TEST

-- Проверяет и показывает локальную струткуру и проверяет доступ к папке на сервере. 

> Проверяет серверную команду \
> Имя локального компьютера \
> Проверяет облачную папку на наличие и на чтение/запись. \
> Проверяет локальную папку на наличие папки синхронизатора, 
> нужных файлов и папок (dest, excludes, tmp, log)


## Как работают режимы синхронизации:


### UP

-- Отправить файлы с локального компьютера на сервер **без удаления**

### DL

-- Считать файлы с сервера на локальный компьютер **без удаления**

### REGULAR

-- два прохода:

1. **UP** - отправляются данные с локального компа на сервер **без удаления**,
2. **DL** - считываются файлы с сервера на локальный компьютер **без удаления**

> **[ РИСК ]**:\
> если на компьютерах одновременно работают с одними и тем-же файлами, \
> то сохранятся только файлы, дата изменения которых будет более новая, \
> "старые" перезапишутся "новыми".\
> За этим нужно следить самостоятельно.

### UP_INIT

-- Отправляются файлы с локального компьютера на сервер <ins>**с удалением расхождений на сервере**</ins>.\
После выполнения отправки файлов на сервер, для всех клиентов устанавливается статус **[DL_INIT]**,\
кроме локального, с которого была выполнена команда, для него устанавливается статус **[REGULAR]**.
            
### DL_INIT

-- Считываются данные с сервера на локальный компьютер \
<ins>**с удалением расхождений на локальном компьютере**</ins>.\
Если эта команда выполняется по требованию сервера, \
т.е. была установлена на сервере с другого компьютера, а не запущена в ручную, \
то на сервере для этого клиента устанавливается статус [REGULAR]

            
### PAUSE

-- Устанавливает статус сервера на "**паузу**". \
В этом режиме синхронизация не происходит.

Это нужно для того, чтобы на самом сервере подправить файлы 
без вмешательства со стороны клиентов, и чтобы во времЯ работы с фалами синхронизация не происходила
            
### UP_EDIT

-- Когда на сервере стоит статус **[PAUSE]**, 
то эта команда работает как **[UP_INIT]** 
для изменения файлов на сервере при отключённой синхронизации
            
### UNPAUSE

-- снимает сервер с **"паузы"** и устанавливает ля всех клиентов статус **[DL_INIT]**,
чтобы все клиенты получили все изменения, внесённые на сервер.

### SHOW_CLOUD_STAT

-- Показать статус сервера для этой папки.
Это значение из файла .sync/status на сервере.

### SHOW_CLOUD_CMD

-- Показать команду сервера для этой папки

### Немного про 'статусы' и 'команды' сервера:

**Статус сервера** -- показывает общую команду для всех клиентов, не зависимо от клиентских 
команд, в том числе и для новых клиентов, для которых команда сервера не определена.

**Команда сервера** -- показывает обязатльную команду для конкретного клиента. 
Для разных клиентов эти команды могут отличаться.

К примеру: Если вы отправили команду '**UP_INIT**', то всем клиентам
будет установлена команда '**DL_INIT**'. 
Когда клиент в следующий раз синхронизируется, он увидит команду '**DL_INIT**'. 
После выполнения этой команды на сервере для этого клиента будет установлен статус '**REGULAR**',
а для всех остальных клиентов статус останется '**DL_INIT**'.

Это нужно для того, чтобы когда вы сделали изменения в файлах, и вам нужно чтобы эти изменения 
были приняты на всех клинтских устройствах. 

Если статус сервера '**PAUSE**', то обмен данными не происходит.
В этом режиме можно только отправлять данные на сервер командой '**UP_EDIT**',
или менять команду сервера на '**UNPAUSE**', которая при следующей синхронизации
установит всем клиентам статус '**DL_INIT**' для обязательной загрузки изменений.

### SHOW_TEST

-- Тестирует настройки синхронизатора. 
Только проверяет локальную структуру, проверяет доступ к папке на сервере и всё это показывает.

### SHOW_LOG
                
Показывает последние сообщения системного лога этого скрипта

### CLOUD_UP_INIT

Запускать так:

    sync_1.sh CLOUD_UP_INIT <локальная_папка> <удалённая_папка>

Создаёт sync-репозиторий из указанной папки.\
<локальная_папка> -- полный или относительный путь к папке, или "."\
<удалённая_папка> -- папка на сервере, которая будет облачным хранилищем\
Обычно вида '**user@host:/путь/папка**' (без '**/**' в конце)

    Действия:

    1. Создаёт в <локальной_папке> папку .sync
       Создаёт файл .sync/excludes (Файл исключений для rsync)
       Создаёт файл .sync/dest внутрь которого записывает облачный адрес
       Создаёт файл .sync/MY_NAME внутрь которого записывает статус [REGULAR]
    2. Копируем <локальную_папку>/.sync на сервер в папку <удалённая_папка>/.sync
    3. Выполняет обычную синхронизацию [REGULAR] для записи данных на сервер.


## Техническая реализация

В папке на компьютере которую нужно синхронизировать нужно создать папку [.sync]
Внутри неё должны быть следующие файлы:

-    **[dest]** -- внутри путь к папке на сервере вида **[user@server:/path/to/folder/sync_folder]**
-    **[excludes]** -- файл со списком исключений для **rsync** (может быть пустым)

Там-же скриптом будут созданы лог-файл [log_sync], временная папка для работы синхронизатора, 
и файл имени этого устройства вида [USER_<hostname>] внутри со статусом этого устройства, считанным с сервера.


## Костыль, который пока не удалось обойти

(хотя, если честно, я им не занимался, поскольку скрипт писал для себя, а мне это не мешало)

Дело в том, что для использования в качестве транспорта ssh нужно указывать порт, 
через который происходит подключение.  Это делается странной командой, 
которую нельзя включить в URL-строку удаленного подключения. 
Её приходится указывать прямо в команде синхронизации.

Вот эта строка: ```--rsh='ssh -p <порт>'```

Номер порта указан в конфиге, \
а сама команда вписана в скрипт в двух местах: \
в функциях ```dl()``` и ```dl_init()```.

Если кто-то подскажет как исправить, буду благодарен за подсказку.




